---
layout: post
title: AMBA CHI
date: 2024-10-20 21:55 +0800
categories: [spec文档阅读, protocol]
tags: []
img_path: /assets/img/chi/
---

Core 未命中读路径最典型的 Flow：

![Core 未命中]({{ page.img_path }}Core 未命中.gif){: width="972" height="589" }

体系结构层

![function]({{ page.img_path }}function.png){: width="972" height="589" }

- 新术语 Requester（请求者）在旧文档中与 master（主设备）同义  
- 新术语 Subordinate（从属设备）在旧文档中与 slave（从设备）同义
- **Write back**：数据首先写入缓存，而不是直接写入主存。当缓存行被替换时，才将数据写回主存。这种策略减少了主存的写操作次数，提高了性能。 
- **Write allocate**：如果目标地址不在缓存中，会先把该地址的数据块加载到缓存，然后再进行写操作。这与“write no-allocate”策略相反，后者在写操作时不加载数据块到缓存。


[CHI协议的发展](https://mp.weixin.qq.com/s/ZpZNBhW7_VECyr5JwDCSfA)

## chap1
Coherence overview：如果两个组件对同一存储器位置的写入可被所有组件以相同的顺序观察到，则存储器区域是一致的。

分布式虚拟内存DVM 接口主要用于 Broadcast TLB Invalidate

- 全面的分层（协议层、网络层、链路层）功能可从小到大的系统扩展
- 4 个统一通道（REQ、SNP、DAT、RSP），减少了连线的数量
- 通过 Link Credit 机制简化了传输流程（不再使用 valid 和 ready 握手）
- 协议中心化的流控，如每个通道 Link Credits 和 RetryAck 防止阻塞机制
- 更精细的 Cache 状态方案，使 Caches 更加及时响应
- 增加用于数据控制的 Cache stashing 和 atomic 操作（ACE5 也开始引入了）



### 1.5.1 缓存一致性模型
下图展示了一个一致性模型，该系统包括三个 Requester 组件，每个组件都具有本地 cache 和一致性协议节点。该协议允许同一存储器位置的 cache 副本驻留在一个或多个请求方组件的 local cache 中。

![coherency_model]({{ page.img_path }}coherency_model.png){: width="972" height="589" }

一致性协议强制规定，每当在某个地址位置发生写操作时，数据值的副本不得超过一份<font color="#d99694">（也就是只有一个cache中存放了该地址的新数据）</font>。一致性协议确保所有请求者在任何给定地址位置观察到正确的数据值。每次存储到某个位置后，其他请求者都可以为自己的本地缓存获取新数据的新副本，以允许存在多个缓存副本。<font color="#d99694">写操作发生时，将其他缓存中该地址的副本无效化或更新</font>

cache line 被定义为大小为 64 字节的以 64 字节对齐的存储器区域。所有一致性都以 cache line 为颗粒度

只有在内存位置的副本不再保存在任何 cache 中之前，才需要更新主内存（无效之前一刻）。该协议不要求主存储器始终保持最新。当某个cache要写主存的时候，该协议使 Requester 组件能够确定 cache line 是否是特定内存位置的唯一副本，<font color="#d99694">如果是唯一的，可以直接改，不然就要用适当的事务通知其他 cache</font>

### 1.5.2 Cache 状态模型

| 状态特征 |  描述 | 
|:---------|--------:|
| Valid | 该 cache line 存在于 cache 中 | 
| Invalid | 该 cache line 不存在于 cache line 中 |
| &nbsp; | &nbsp; | 
| Unique | 该 cache line 仅存在于该 cache 中 | 
| Shared | 该 cache line 可能存在于多个 cache 中（并不能保证） |
| &nbsp; | &nbsp; | 
| Clean  | 该 cache 不负责更新主存 |
| Dirty | cache line 已相对于主内存进行了修改，并且此 cache 必须确保最终更新主存 |
| &nbsp; | &nbsp; | 
| Full/Partial/Empty | cache line的字节有效部分 |

### 1.6 组件协议node

![node]({{ page.img_path }}node.png){: width="972" height="589" }

### 1.7 数据源

如果数据提供者能够将数据响应直接转发给请求者而不是通过 Home，则可以删除在此读取事务流中获取数据的跃点。

![data_provide]({{ page.img_path }}data_provide.png){: width="972" height="589" }

**Direct Memory Transfer (DMT)** 是有条件的，因为有些事务的响应必须要回到 HNF（Home 节点），后面深究。

**Direct Cache Transfer (DCT)** 读取事务流中的数据提供者必须通知 Home 它已经向请求者发送了数据，在某些情况下，它还必须向 Home 发送数据副本。

**Direct Write-data Transfer (DWT)**

![DMT]({{ page.img_path }}DMT.png){: width="972" height="589" }
![DCT]({{ page.img_path }}DCT.png){: width="972" height="589" }
![DWT]({{ page.img_path }}DWT.png){: width="972" height="589" }


## chap2 Transactions分类
### Read
1.Requester会获得一个数据响应；

2.会导致数据在系统其它agents之间的搬移；

3.会导致Request中cacheline状态的改变；

4.会导致系统中其它Requesters的 cacheline状态改变，

read类型的操作分为两类，non-allocating read 和allocating read

![read_class]({{ page.img_path }}read_class.png){: width="972" height="589" }

- ReadNoSnp

RN请求去Non—snoopable address region获取数据，不需要snoop其它RN或者HN访问任意空间。

- ReadNoSnpSep

与ReadNoSnp类似，只是告知Completer只需要返回data response。

- ReadOnce

该命令访问的是snoopable空间，用以获取一份数据，但是该数据不会在当前的RN中缓存；<font color="#d99694">也就是说，只是用一下该地址的数据；无需allocate到本地私有cache.</font>

- ReadOnceCleaninvalid

	- 访问的是snoopable的地址空间；获取该地址的数据；
	- 建议其他拥有该地址copy的RN，其状态变成invalid，但是不是强制的；
	- 如果dirty的cacheline被invalid了，需要将数据写入主存；
	- 当application想要该地址的数据仍然是有效的，但是近期又不使用的时候，可以使用该命令，而不是readonce/readoncemakeinvalid;

此命令可以提高cache效率，因为其主动将近期不使用的cache line从cache中invalid掉;

此命令不能代替CMO （Cache Maintenance Operation）操作，因为它不保证所有的cachline都变成了invalid;

由于这个命令会导致cache line的invalid，因此，当系统中有其他人在使用exclusive访问时，需要小心。

-  ReadOnceMakelnvalid

	- 访问的是snoopable的地址空间；获取该地址的数据；
	- 建议其他拥有该地址copy的RN，其状态变成invalid，但是不是强制的；
	- 如果dirty的cache line被invalid了，则直接丢弃数据；
	- 当application知道后续这个地址的数据不再使用，即不再需要该最新数据之后，可以发送该命令；

此种命令在上述场景下，减少了writeback数据到DDR的带宽和时间；

此命令不能代替CMO（Cache Maintenance Operation）操作，因为它不保证所有的cache line都变成了invalid;

由于这个命令会导致cache line的invalid，因此，当系统中有其他人在使用exclusive访问时，需要小心；

此命令必须保证，在返回响应之前，先将该cache line invalid掉，并且在这个时刻点之后的所有写，都不受此次invalid的影响。





## 附录 术语
[术语查询](https://blog.csdn.net/qq_40147893/article/details/136596743)