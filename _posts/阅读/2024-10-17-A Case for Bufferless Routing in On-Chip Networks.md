---
layout: post
title: paper：A Case for Bufferless Routing in On-Chip Networks
date: 2024-10-17 13:18 +0800
categories: [读书笔记, paper]
tags: []
img_path: /assets/img/paper/
---
<script> var password = prompt("请输入密码："); if (password !== "xiaokai") {document.body.innerHTML = "访问被拒绝。"; } </script>


论文中提出的BLESS算法是无缓冲路由的一种实现方式。当目标输出端口被占用时，路由器通过偏移让数据包选择非理想路径继续前进，从而避免堵塞。尽管无缓冲路由在能量效率上有显著优势，但也会增加数据包的延迟，特别是在发生偏移的情况下。然而，<font color="#d99694">论文指出在许多实际应用中，网络负载较低，偏移事件发生较少(CPU持续注入，一段时间没得到回应就停止注入了)</font>，因此不会对整体性能造成显著影响。但是，无缓冲区路由不能轻易应用于具有定向链路的网络，例如 Butterfly 网络。因为被转移的数据包可能无法再到达其目的地

无缓冲布线消除了片上网络设计中的输入缓冲器和虚拟通道。消除输入缓冲区和虚拟通道不仅可以降低路由器的设计复杂性，还可以减少路由器延迟。

论文设计了一种“最老优先”（Oldest-First）机制来避免活锁问题。通过优先处理网络中存在时间最长的数据包，保证所有数据包都能最终到达目的地。

> 这只是个idea，他们并没有解决router中的复杂设计。如果设计的不好，可能所有的包都在偏离原来的最短路径，走了很多弯路
{: .prompt-tip }

[这里有视频拓展，但是我暂时听不懂Computer Architecture - Lecture 26: On-Chip Networks (Fall 2023) - YouTube](https://www.youtube.com/watch?v=6abzvI9xzRI)


## FLIT-BLESS
在每个周期中，router 使用 flit-ranking 组件对所有传入的 fit 进行排名。

对于每个 flit， port-priorization 组件按照它们对这个 fit 的 “可取性” 的顺序对可用的输出端口进行排名

(1)**使用偏转路由并确保路由器中的输出端口数大于或等于输入端口数，确保不会发生死锁。**
(2)**通过确保回复始终可以到达其目的地(Oldest-First)，避免了协议（请求-回复）死锁**
(3)**在 OF 中，最旧的 flit 排名最高，因此，它总是可以被分配一个生产方向。这保证了不会发生活锁，因为一旦 Flit 成为网络中最古老的 Flit，它就不能再被偏转，并保证向前推进，直到到达目的地。**
> 在片上网络（NoC）中，活锁（livelock）是一种网络现象，指的是数据包在网络中不断移动或被重路由，但却永远无法到达目标节点。尽管这些数据包不会完全停止移动，但由于不断地被偏移到其他路径，它们无法实现前进，导致系统无法完成通信任务。活锁与死锁不同，死锁是指网络中的所有数据包停滞不前，而活锁则意味着数据包仍在移动，但毫无进展。
{: .prompt-tip }

下面是sort flits by age：将四个fliit排序出age来判断谁是old first

![age]({{ page.img_path }}age.png){: width="972" height="589" }
## BLESS Wormhole Routing
这是对FLIT-BLESS的优化，它将 BLESS 与虫洞路由的思想相结合。理想情况下，每个数据包的第一次 fit 应仅包含标头信息 （head-flit），并且所有后续 fit 都应仅遵循前面的 fit。如果一个头被偏转，整个数据包将跟随这个头

### 问题1：连续路由下的注入问题
在 FLIT-BLESS 网络中，当**至少有一个输入端口空闲**时，处理器可以向路由器注入一个数据包（定义的注入策略）。这就造成了一个问题：
> 如果一个数据包的所有 flit 必须连续路由（这是虫洞路由的特点），那么前面的注入规则就可能导致问题。 一旦处理器开始注入一个数据包（例如包含多个 flit ），这个注入过程需要连续的多个时钟周期，在这段时间中，由于偏转机制，所有的Route被接踵而来的包占满输入，处理器再注入新的数据包（之前的数据包还在继续注入）就会导致输入处理的flit数量多余输出端口数量，内部又没有缓冲区
{: .prompt-danger }

> 连续路由：在发送第一个 flit 后，后续的 flit 必须在连续的时钟周期内到达下一个路由器，而不能被其他数据插入或中断。
{: .prompt-tip }

### 问题2：活锁问题
路由器只对到达的 **头 flit** 进行仲裁，决定哪个 worm 可以通过。body flit 不参与仲裁，它们会直接占用输出端口。当其他 worm 的头 flit 已经通过了，现在正在传输body flit。最老的 worm 的头 flit 没有机会去竞争输出端口。这样最老的 worm 被不断转向（deflected），没有被优先处理，从而形成活锁

### 问题解决方法：
注入策略不变，但是当源在注入worm时，新worm到达所有 4 个输入端口，则注入的蠕虫将被截断。一旦一个输入端口空闲，就可以注入worm的第二部分。当worm被截断时，剩余的 flit（第 4 到第 8 个 flit）尚未注入，需要等待输入端口空闲。由于这是截断后的第一 flit，它被视为新的**头 flit**。这个新的头 flit 将携带必要的路由信息，引导剩余 flit 在网络中传输。

为了避免活锁，需要改变端口优先级策略。
![端口优先级策略]({{ page.img_path }}worm_port_priority.png){: width="972" height="589" }
当高优先级传输过来，当前正在传输的会被截断，被截断的第二部分的第一个flit当作头重新分配

## BLESS with Buffers
如果不使用缓冲区，BLESS算法会让这些数据包偏移到其他路径，虽然避免了阻塞，但可能增加传输时间，导致延迟

路由器为每个 input port 维护一个位 mustSchedule。当与此 input 端口关联的缓冲区已满时，该位设置为 true。这意味着此缓冲区中最早的 Flit 现在是 mustSchedule，即，它必须在下一个周期中发送出去，以便为可能到达该 input 端口的新传入 Flit 腾出空间。如果路由器没有在每个周期发送所有 mustSchedule fit，则可能会发生突然必须发送的 fit 多于其输出端口的情况。

端口优先级策略参见上图

> 最后，请注意，带缓冲区的 BLESS 也可以与多个虚拟通道结合使用
{: .prompt-tip }

## 对于减少延迟的设计策略
在**baseline router**中，VA（找到输出端口的VC（即下一个路由器输入端口的VC））和SA（仲裁Virtual Channel和物理输出通道）

本文设计没有VC 没有Buffer，消除了BW和VA/SA

![流水线优化]({{ page.img_path }}流水线Route.png){: width="972" height="589" }
**（lookahead）技术**来进一步优化，如图 1(c) 所示。其基本思想是在 flit（流控单元）实际到达之前的一个时钟周期，通过一条独立的窄带链路提前传递足够的关于该 flit 的信息。

具体来说，预见信息的链路传输（简称 LA LT）与 flit 的交换机传输（ST）是并行进行的。当 flit 本身在链路上传输时，下一个路由器利用预先收到的预见信息执行路由计算（RC）。路由计算的结果被存储在通向 ST 阶段的流水线锁存器中。

因此，当 flit 在下一个周期实际到达时，路由器已经完成了路由计算，flit 可以直接进入 ST 阶段。这种基于预见的路由方式使得 flit 只需经过一个阶段（ST）就能通过路由器流水线。图 1(c) 中用深色阴影表示了预见流水线阶段。通过这种优化，BLESS 路由器可以实现单周期延迟。



## 缺点
然而，取消虚拟信道（virtual channels）也带来了一些缺点：我们的无缓冲路由技术中无法轻松地容纳不同类别的流量，因为它们不能被分配到不同的虚拟信道。这是我们现有设计的一个不足之处，我们计划在未来解决。为了替代虚拟信道，我们的机制需要使用路由算法来区分不同类别的流量。例如，可以为每个数据包增加其优先级。无缓冲路由算法可以被设计为在路由决策中优先考虑这些数据包：算法可以被设计为最小化高优先级流量类别遭受的偏转（deflection）。

本质上，为了对不同的流量类别进行差异化处理，做出偏转决策的路由逻辑需要了解每个数据包的类别。设计这样的算法虽然是一个非常有趣的研究方向，但超出了本文的范围。


